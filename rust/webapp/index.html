<!DOCTYPE HTML>
<html>
<head>
<style>
a.canvasjs-chart-credit {
    visibility: hidden;
}
</style>
</head>

<body>

<div style="margin: auto; display: grid; grid-template-columns: 300px 800px; width: 1100px;">
<div>

<p>
<input type="checkbox" id="hideHist"> Hide Summary Stats<br>
</p>

<p>
<input type="checkbox" id="sourceKV"> Collect KV Logs<br>
<input type="checkbox" id="sourceSched"> Collect Sched Events<br>
<input type="button" value="Set data collection" id="enableSource">
</p>

<p>
Choose Y Axis (KV store operations) <br>
<input type="radio" name="setYValue" id="qps"> Operations per Sec (OPS) <br>
<input type="radio" name="setYValue" id="lat"> Max Latency per Sec (LPS)
</p>

<p>
Choose Y Axis groupings <br>
<input type="checkbox" name="setYGroup" value="kvcpu"> CPU <br>
<input type="checkbox" name="setYGroup" value="kvtid"> TID <br>
<input type="checkbox" name="setYGroup" value="kvop"> Read / Write
</p>

<p>
<input type="button" value="Update Chart" id="updatePlots">
</p>

<p> <input id="pauseBox" type="checkbox">Pause</input></p>
</div>

<div style="width: auto; display: grid; grid-template-rows: 200px 300px 300px; row-gap: 20px">
<div id="plotA"></div>
<div id="plotB"></div>
<div id="plotC"></div>
</div>
</div>

<script src="https://cdn.canvasjs.com/canvasjs.min.js"></script>
<script>

var dataRequests = [];
var hideHistogram = false;

var plotA = new CanvasJS.Chart("plotA", {
	axisX: [{
        interval: 1,
        intervalType: "second",
        labelWrap: false,
        labelTextAlign: "right",
        labelAngle: -45,
        titleFontSize: 14,
        labelFontSize: 14,
        lineColor: "#ddd",
	}],
	axisY:{
        title: "QPS",
		includeZero: true,
        titleFontSize: 14,
        labelFontSize: 14,
        tickPlacement: "inside", //Change it to "outside"
        labelPlacement: "inside", //Change it to "outside"
        gridColor: "#ddd"
	},
    width: 800,
	data: []
})

var plotB = new CanvasJS.Chart("plotB", {
	axisX: [{
        interval: 1,
        intervalType: "second",
        labelWrap: false,
        labelTextAlign: "right",
        labelAngle: -45,
        titleFontSize: 14,
        labelFontSize: 14,
        lineColor: "#ddd",
        labelFormatter: function(){
            return " ";
        }
	}],
	axisY:{
        title: "QPS",
		includeZero: true,
        titleFontSize: 14,
        labelFontSize: 14,
        tickPlacement: "inside", //Change it to "outside"
        labelPlacement: "inside", //Change it to "outside"
        gridColor: "#ddd"
	},
    width: 800,
	data: []
});

var plotC = new CanvasJS.Chart("plotC", {
	axisX: [{
        interval: 1,
        intervalType: "second",
        labelWrap: false,
        labelTextAlign: "right",
        labelAngle: -45,
        titleFontSize: 14,
        labelFontSize: 14,
        lineColor: "#ddd",
        labelFormatter: function(){
            return " ";
        }
	}],
	axisY:{
        title: "QPS",
		includeZero: true,
        titleFontSize: 14,
        labelFontSize: 14,
        tickPlacement: "inside", //Change it to "outside"
        labelPlacement: "inside", //Change it to "outside"
        gridColor: "#ddd",
	},
    width: 800,
	data: []
});

function isPaused() {
    var pauseField = document.getElementById('pauseBox');
    return pauseField.checked;
}

function updatePlotA(points, min_ts, max_ts) {
    console.log("Updating plot A with points", points);
    var newData = []
    newData.push({
		type: "line",
		name: "init",
		showInLegend: false,
        xValueType: "dateTime",
		xValueFormatString: "hh:mm",
		dataPoints: points
	})
    plotA.options.data = newData;
    plotA.options.axisX[0].maximum = max_ts;
    plotA.options.axisX[0].minimum = min_ts;
}

function updatePlotBHistogram(points, min_ts, max_ts, visible) {
    if (plotB.options.data[0]) {
        plotB.options.data[0].dataPoints = points;
    } else {
        var newData = []
        newData.push({
	    	type: "line",
	    	name: "init",
	    	showInLegend: false,
            xValueType: "dateTime",
	    	xValueFormatString: "hh:mm",
	    	dataPoints: points
	    })
        plotB.options.data = newData;
    }
    plotB.options.data[0].visible = visible;
    plotB.options.axisX[0].maximum = max_ts;
    plotB.options.axisX[0].minimum = min_ts;
}

function updatePlotCHistogram(points, min_ts, max_ts, visible) {
    if (plotC.options.data[0]) {
        plotC.options.data[0].dataPoints = points;
    } else {
        var newData = []
        newData.push({
	    	type: "line",
	    	name: "init",
	    	showInLegend: false,
            xValueType: "dateTime",
	    	xValueFormatString: "hh:mm",
	    	dataPoints: points
	    })
        plotC.options.data = newData;
    }
    plotC.options.data[0].visible = visible;
    plotC.options.axisX[0].maximum = max_ts;
    plotC.options.axisX[0].minimum = min_ts;
}

function updatePlotB(newData, min_ts, max_ts) {
    console.log("New data: ", newData);
    var data = newData.data;

    // First data is always the histogram
    var newScatterData = [];
    newScatterData.push(plotB.options.data[0]);

    for (i = 0; i < data.length; i++) {
        var source = data[i].source;
        var sourceData = data[i].data;
        newScatterData.push({
	    	type: "line",
	    	name: source,
	    	showInLegend: true,
            xValueType: "dateTime",
	    	xValueFormatString: "hh:mm",
	    	dataPoints: sourceData
	    })
    }
    plotB.options.data = newScatterData;
    plotB.options.axisX[0].maximum = max_ts;
    plotB.options.axisX[0].minimum = min_ts;
}

function updatePlotC(newData, min_ts, max_ts) {
    console.log("New data: ", newData);
    var data = newData.data;

    // First data is always the histogram
    var newScatterData = [];
    newScatterData.push(plotC.options.data[0]);

    for (i = 0; i < data.length; i++) {
        var source = data[i].source;
        var sourceData = data[i].data;
        newScatterData.push({
	    	type: "line",
	    	name: source,
	    	showInLegend: true,
            xValueType: "dateTime",
	    	xValueFormatString: "hh:mm",
	    	dataPoints: sourceData
	    })
    }
    plotC.options.data = newScatterData;
    plotC.options.axisX[0].maximum = max_ts;
    plotC.options.axisX[0].minimum = min_ts;
}

function updateHistogram(min_ts, max_ts, shouldRender) {
    var request = JSON.stringify({
        max_ts_millis: max_ts,
        min_ts_millis: min_ts
    });
    console.log(request);

    var e = document.getElementById("hideHist");
    var visible = !e.checked;

    var request = new Request("http://localhost:3000/histogram", {
        method: 'POST',
        body: request,
        headers: new Headers({
            'Content-Type': 'application/json'
        })
    });

    fetch(request)
        .then(data => data.json())
        .then(data => {
            console.log("Result", data);
            updatePlotA(data, min_ts, max_ts);
            updatePlotBHistogram(data, min_ts, max_ts, visible);
            updatePlotCHistogram(data, min_ts, max_ts, visible);
            if (shouldRender) {
                plotA.render();
                plotB.render();
                plotC.render();
            }
        });
}

function updatePlots() {
    var max = Date.now() - 1000;
    var min = max - (1000 * 10); // in millis

    updateHistogram(min, max, dataRequests.length == 0);

    if (dataRequests.length > 0) {
        var request = JSON.stringify({
            lines: dataRequests,
            max_ts_millis: max,
            min_ts_millis: min,
        });
        var request = new Request("http://localhost:3000/scatterPlot", {
            method: 'POST',
            body: request,
            headers: new Headers({
                'Content-Type': 'application/json'
            })
        });

        fetch(request)
            .then(data => data.json())
            .then(data => {
                console.log(data);
                updatePlotB(data, min, max);
                updatePlotC(data, min, max);
                plotA.render();
                plotB.render();
                plotC.render();
            });
    }

}

/*
    {
        data: [
            { source: "SourceA", data: [ { x: int, y: int } ] },
        ]
    }
*/

updatePlots();
setInterval(function() {
    var paused = isPaused();
    console.log(paused);
    if (!paused) {
        updatePlots()
    }
}, 1000);

document.getElementById("updatePlots").onclick = function() {

    var source = "";
    var field = "";
    var group = [];
    var agg = "";

    var e = document.getElementById("qps");
    if (e.checked) {
        source = "kv";
        field = "kvdur";
        agg = "count";
    }

    var e = document.getElementById("lat");
    if (e.checked) {
        source = "kv";
        field = "kvdur";
        agg = "max";
    }

    var e = document.getElementsByName("setYGroup");
    for (i = 0; i < e.length; i++) {
        if (e[i].checked) {
            group.push(e[i].value);
        }
    }

    dataRequsts = [];
    dataRequests.push({
        source: source,
        field: field,
        group: group,
        agg: agg,
    });
}

document.getElementById("enableSource").onclick = function() {

    var e = document.getElementById("sourceKV");
    var collectKv = e.checked;

    var e = document.getElementById("sourceSched");
    var collectSched = e.checked;

    var request = JSON.stringify({
        collectKv: collectKv,
        collectSched: collectSched
    })

    var request = new Request("http://localhost:3000/setCollection", {
        method: 'POST',
        body: request,
        headers: new Headers({
            'Content-Type': 'application/json'
        })
    });
    fetch(request)
        .then(res => res.json());
}

</script>

</body>
</html>

